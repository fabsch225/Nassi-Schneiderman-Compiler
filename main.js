/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NSD_JS
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/nassi_svg_api.ts
function createStartEndBlock(x, y, width, height, content) {
  const h = 20;
  const svgAppendix = `
        <rect x="${x}" y="${y}" width="${width}" height="${h}" stroke="black" fill="lightblue" />
        <text x="${x + width / 2}" y="${y + height / 2}" font-size="14px" fill="black" text-anchor="middle">${content}</text>
    `;
  return { svgAppendix, children: [] };
}
function createSequenceBlock(x, y, width, height, content) {
  const svgAppendix = `
        <rect x="${x}" y="${y}" width="${width}" height="${height}" stroke="black" fill="lightgreen" />
        <text x="${x + width / 2}" y="${y + height / 2}" font-size="14px" fill="black" text-anchor="middle">${content}</text>
    `;
  return { svgAppendix, children: [] };
}
function createDecisionBlock(x, y, width, height, question, answerA, answerB, ratio) {
  const h = 20;
  const h_extra = h / 2;
  let left_offset = width * ratio;
  let svgAppendix;
  if (ratio === -1) {
    left_offset = width * 0.8;
    svgAppendix = `
            <polygon points="${x},${y} ${x + width},${y} ${x + left_offset},${y + h}" stroke="black" fill="lightyellow" />
            <polygon points="${x},${y} ${x},${y + h + h_extra} ${x + left_offset},${y + h + h_extra} ${x + left_offset},${y + h}" stroke="black" fill="lightyellow" />
            <text x="${x + left_offset}" y="${y + h / 2}" font-size="14px" fill="black" text-anchor="middle">${question}</text>
            <text x="${x + width / 8}" y="${y + h}" font-size="14px" fill="black" text-anchor="middle">${answerA}</text>
        `;
  } else {
    svgAppendix = `
            <polygon points="${x},${y} ${x + width},${y} ${x + left_offset},${y + h}" stroke="black" fill="lightyellow" />
            <polygon points="${x},${y} ${x},${y + h + h_extra} ${x + left_offset},${y + h + h_extra} ${x + left_offset},${y + h}" stroke="black" fill="lightyellow" />
            <polygon points="${x + width},${y} ${x + width},${y + h + h_extra} ${x + left_offset},${y + h + h_extra} ${x + left_offset},${y + h}" stroke="black" fill="lightyellow" />
            <text x="${x + left_offset}" y="${y + h / 2}" font-size="14px" fill="black" text-anchor="middle">${question}</text>
            <text x="${x + 7 * width / 8}" y="${y + h}" font-size="14px" fill="black" text-anchor="middle">${answerB}</text>
            <text x="${x + width / 8}" y="${y + h}" font-size="14px" fill="black" text-anchor="middle">${answerA}</text>
        `;
  }
  const childA = { start_x: x, start_y: y + h + h_extra, width: left_offset, height: height - h - h_extra };
  const childB = { start_x: x + left_offset, start_y: y + h + h_extra, width: width - left_offset, height: height - h - h_extra };
  return { svgAppendix, children: [childA, childB] };
}
function createPreLoopBlock(x, y, width, height, arguments_) {
  const h = 20;
  const svgAppendix = `
        <polygon points="
            ${x},${y}
            ${x + width},${y}
            ${x + width},${y + h}
            ${x + h},${y + h}
            ${x + h},${y + height - h}
            ${x + width},${y + height - h}
            ${x + width},${y + height}
            ${x},${y + height}
            ${x},${y}
        " stroke="black" fill="lightpink" />
        <text x="${x + width / 2}" y="${y + h / 2}" font-size="14px" fill="black" text-anchor="middle">${arguments_}</text>
    `;
  const child = { start_x: x + h, start_y: y + h, width: width - h, height: height - 2 * h };
  return { svgAppendix, children: [child] };
}
function createPostLoopBlock(x, y, width, height, arguments_) {
  const h = 20;
  const svgAppendix = `
        <polygon points="
            ${x},${y}
            ${x + width},${y}
            ${x + width},${y + h}
            ${x + h},${y + h}
            ${x + h},${y + height - h}
            ${x + width},${y + height - h}
            ${x + width},${y + height}
            ${x},${y + height}
            ${x},${y}
        " stroke="black" fill="lightpink" />
        <text x="${x + width / 2}" y="${y + h / 2}" font-size="14px" fill="black" text-anchor="middle">do</text>
        <text x="${x + width / 2}" y="${y + height - h / 2}" font-size="14px" fill="black" text-anchor="middle">while(${arguments_})</text>
    `;
  const child = { start_x: x + h, start_y: y + h, width: width - h, height: height - 2 * h };
  return { svgAppendix, children: [child] };
}

// src/converter.ts
function convert(x, y, width, height, tree, name) {
  let svg = "";
  svg += createStartEndBlock(x, y, width, 20, name).svgAppendix;
  let conversion = convert_backend(x, y + 20, width, height - 20, tree);
  svg += conversion.svgAppendix;
  svg += createStartEndBlock(x, y + 20 + conversion.height, width, 20, "End").svgAppendix;
  return { svgString: svg, height: conversion.height + 40 };
}
function convert_backend(x, y, width, height, tree) {
  console.log("Converting ", tree);
  let svgAppendix = "";
  let current_y = y;
  for (let block of tree) {
    let h = getHeight(block);
    if (block.type == -1) {
      svgAppendix += createSequenceBlock(x, current_y, width, h, block.name).svgAppendix;
      current_y += h;
    } else if (block.type == 0) {
      svgAppendix += createSequenceBlock(x, current_y, width, h, block.name + "(" + block.arguments[0] + ")").svgAppendix;
      current_y += h;
    } else if (block.type == 1) {
      if (block.branches.length != 1) {
        throw new Error("Expected 1 branches, Nassi-Shneiderman diagrams only support single IF or one IF-ELSE statement");
      }
      var sub_block = createDecisionBlock(x, current_y, width, h, block.name + "(" + block.arguments[0] + ")", "TRUE", "FALSE", -1);
      svgAppendix += sub_block.svgAppendix;
      var bounds1 = sub_block.children[0];
      svgAppendix += convert_backend(bounds1.start_x, bounds1.start_y, bounds1.width, bounds1.height, block.branches[0]).svgAppendix;
      current_y += h;
    } else if (block.type == 2) {
      if (block.branches.length != 2) {
        throw new Error("Expected 2 branches, Nassi-Shneiderman diagrams only support single IF or one IF-ELSE statement");
      }
      let ratio = getMaxChildCount(block.branches[0]) / (getMaxChildCount(block.branches[0]) + getMaxChildCount(block.branches[1]));
      console.log("RATIO", ratio);
      var sub_block = createDecisionBlock(x, current_y, width, h, block.name + "(" + block.arguments[0] + ")", "TRUE", "FALSE", ratio);
      svgAppendix += sub_block.svgAppendix;
      var bounds1 = sub_block.children[0];
      var bounds2 = sub_block.children[1];
      svgAppendix += convert_backend(bounds1.start_x, bounds1.start_y, bounds1.width, bounds1.height, block.branches[0]).svgAppendix;
      svgAppendix += convert_backend(bounds2.start_x, bounds2.start_y, bounds2.width, bounds2.height, block.branches[1]).svgAppendix;
      current_y += h;
    } else if (block.type == 10) {
      if (block.branches.length != 1) {
        throw new Error("Expected 1 branches, Nassi-Shneiderman diagrams only support single loop");
      }
      var sub_block = createPreLoopBlock(x, current_y, width, h, block.name + "(" + block.arguments[0] + ")");
      svgAppendix += sub_block.svgAppendix;
      var bounds1 = sub_block.children[0];
      svgAppendix += convert_backend(bounds1.start_x, bounds1.start_y, bounds1.width, bounds1.height, block.branches[0]).svgAppendix;
      current_y += h;
    } else if (block.type == 11) {
      if (block.branches.length != 1) {
        throw new Error("Expected 1 branches, Nassi-Shneiderman diagrams only support single loop");
      }
      var sub_block = createPostLoopBlock(x, current_y, width, h, block.name + "(" + block.arguments[0] + ")");
      svgAppendix += sub_block.svgAppendix;
      var bounds1 = sub_block.children[0];
      svgAppendix += convert_backend(bounds1.start_x, bounds1.start_y, bounds1.width, bounds1.height, block.branches[0]).svgAppendix;
      current_y += h;
    }
  }
  return { svgAppendix, height: current_y - y };
}
function getMaxChildCount(branch) {
  let counts = [];
  for (let block of branch) {
    if (block.type == 0 || block.type == -1) {
      counts.push(1);
    } else if (block.type == 2) {
      let countA = getMaxChildCount(block.branches[0]);
      let countB = getMaxChildCount(block.branches[1]);
      counts.push(countA + countB);
    } else {
      counts.push(getMaxChildCount(block.branches[0]));
    }
  }
  return Math.max(...counts);
}
function getHeight(block) {
  const base_h = 20;
  if (block.type == 0 || block.type == -1) {
    return base_h;
  } else {
    let heights = [];
    console.log(block);
    for (let branch of block.branches) {
      let current_heigth = 0;
      for (let sub_block of branch) {
        current_heigth += getHeight(sub_block);
      }
      heights.push(current_heigth);
    }
    if (block.type == 10 || block.type == 11) {
      return base_h * 2 + Math.max(...heights);
    } else if (block.type == 1 || block.type == 2) {
      return base_h * 3 / 2 + Math.max(...heights);
    }
  }
  return 0;
}

// src/compiler.ts
var tokens = ["if", "for", "foreach", "while", "do"];
var branchers = ["{", "}"];
var brackets = ["(", ")"];
function is_token(s) {
  return tokens.includes(s);
}
function is_token_prefix(s) {
  if (is_token(s)) {
    return false;
  }
  for (let i = 0; i < tokens.length; i++) {
    if (tokens[i].startsWith(s)) {
      return true;
    }
  }
  return false;
}
function get_arguments(s, i) {
  if (s[i] !== brackets[0]) {
    console.log(s[i]);
    throw new Error("Expected (");
  }
  let arguments_ = "";
  let next_char = s[i + 1];
  i += 1;
  while (next_char !== brackets[1]) {
    arguments_ += s[i];
    i++;
    next_char = s[i];
  }
  return { args: arguments_, index: i + 1 };
}
function get_branch(s, i) {
  var branch = "";
  var open_brackets = 0;
  while (open_brackets >= 0) {
    if (i > s.length) {
      throw new Error("Expected }");
    }
    branch += s[i];
    i++;
    if (s[i] === branchers[0]) {
      open_brackets++;
    } else if (s[i] === branchers[1]) {
      open_brackets--;
    }
  }
  return { content: branch, index: i + 1 };
}
function lex_front(s) {
  let without_spaces = s.replace(/\s/g, "");
  return lex_back(without_spaces);
}
function lex_back(s) {
  console.log("Compiling: " + s);
  let i = 0;
  let current_token = "";
  let tokens2 = [];
  while (i < s.length) {
    while (is_token_prefix(current_token)) {
      current_token += s[i];
      i++;
    }
    if (is_token(current_token)) {
      if (current_token === "if") {
        var type = 1;
        let branches2 = [];
        let arguments_2 = [];
        var current_arguments = get_arguments(s, i);
        i = current_arguments.index;
        console.log(current_arguments.args);
        if (s[i] !== branchers[0]) {
          console.log(s[i]);
          throw new Error("Expected {");
        }
        i += 1;
        var branch = get_branch(s, i);
        i = branch.index;
        branches2.push(lex_back(branch.content));
        arguments_2.push(current_arguments.args);
        while (s.substring(i, i + 6) === "elseif") {
          i += 6;
          var current_arguments = get_arguments(s, i);
          i = current_arguments.index;
          if (s[i] !== branchers[0]) {
            throw new Error("Expected {");
          }
          i += 1;
          var branch = get_branch(s, i);
          i = branch.index;
          branches2.push(lex_back(branch.content));
          arguments_2.push(current_arguments.args);
        }
        if (s.substring(i, i + 4) === "else") {
          type = 2;
          i += 4;
          i += 1;
          var branch = get_branch(s, i);
          i = branch.index;
          branches2.push(lex_back(branch.content));
        }
        tokens2.push({
          type,
          name: current_token,
          arguments: arguments_2,
          branches: branches2
        });
      } else if (current_token === "for" || current_token === "foreach" || current_token === "while") {
        var type = 10;
        var branches = [];
        var arguments_ = [];
        var current_arguments = get_arguments(s, i);
        i = current_arguments.index;
        console.log(current_arguments.args);
        if (s[i] !== branchers[0]) {
          console.log(s[i]);
          throw new Error("Expected {");
        }
        i += 1;
        var branch = get_branch(s, i);
        i = branch.index;
        branches.push(lex_back(branch.content));
        arguments_.push(current_arguments.args);
        tokens2.push({
          type,
          name: current_token,
          arguments: arguments_,
          branches
        });
      } else if (current_token == "do") {
        var type = 11;
        var branches = [];
        var arguments_ = [];
        if (s[i] !== branchers[0]) {
          console.log(s[i]);
          throw new Error("Expected {");
        }
        i += 1;
        var branch = get_branch(s, i);
        i = branch.index;
        branches.push(lex_back(branch.content));
        if (s.substring(i, i + 5) !== "while") {
          throw new Error("Expected while");
        }
        i += 5;
        var current_arguments = get_arguments(s, i);
        arguments_.push(current_arguments.args);
        i = current_arguments.index;
        tokens2.push({
          type,
          name: current_token,
          arguments: arguments_,
          branches
        });
      }
    } else {
      while (s[i] != brackets[0] && s[i] != ";") {
        if (i >= s.length) {
          throw new Error("Expected ( or ;");
        }
        current_token += s[i];
        i++;
      }
      if (s[i] === ";") {
        i++;
        tokens2.push({
          type: -1,
          name: current_token,
          arguments: [],
          branches: []
        });
      } else {
        var current_arguments = get_arguments(s, i);
        i = current_arguments.index;
        tokens2.push({
          type: 0,
          name: current_token,
          arguments: [current_arguments.args],
          branches: []
        });
        if (s[i] == ";") {
          i += 1;
        }
      }
    }
    current_token = "";
  }
  return tokens2;
}

// main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var NSD_JS = class extends import_obsidian.Plugin {
  async onload() {
    this.registerMarkdownCodeBlockProcessor("nsd_js", (source, el, ctx) => {
      const tree = lex_front(source);
      const svg = convert(0, 0, 650, 1e3, tree, "start");
      const innerSvg = svg.svgString;
      const height = svg.height;
      el.innerHTML = "<svg width='650' height='" + height + "'>" + innerSvg + "</svg>";
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvbmFzc2lfc3ZnX2FwaS50cyIsICJzcmMvY29udmVydGVyLnRzIiwgInNyYy9jb21waWxlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTW9kYWwsIE5vdGljZSwgUGx1Z2luLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSAnb2JzaWRpYW4nO1xuXG5pbXBvcnQgeyBjb252ZXJ0IH0gZnJvbSAnLi9zcmMvY29udmVydGVyJztcbmltcG9ydCB7IGxleF9mcm9udCB9IGZyb20gJy4vc3JjL2NvbXBpbGVyJztcbi8vIFJlbWVtYmVyIHRvIHJlbmFtZSB0aGVzZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIVxuXG5pbnRlcmZhY2UgTXlQbHVnaW5TZXR0aW5ncyB7XG5cdG15U2V0dGluZzogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNeVBsdWdpblNldHRpbmdzID0ge1xuXHRteVNldHRpbmc6ICdkZWZhdWx0J1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOU0RfSlMgZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogTXlQbHVnaW5TZXR0aW5ncztcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cdFx0dGhpcy5yZWdpc3Rlck1hcmtkb3duQ29kZUJsb2NrUHJvY2Vzc29yKFwibnNkX2pzXCIsIChzb3VyY2UsIGVsLCBjdHgpID0+IHtcblx0XHRcdGNvbnN0IHRyZWUgPSBsZXhfZnJvbnQoc291cmNlKTtcblx0XHRcdGNvbnN0IHN2ZyA9IGNvbnZlcnQoMCwgMCwgNjUwLCAxMDAwLCB0cmVlLCBcInN0YXJ0XCIpO1xuXHRcdFx0Y29uc3QgaW5uZXJTdmcgPSBzdmcuc3ZnU3RyaW5nO1xuXHRcdFx0Y29uc3QgaGVpZ2h0ID0gc3ZnLmhlaWdodDtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPHN2ZyB3aWR0aD0nNjUwJyBoZWlnaHQ9J1wiICsgaGVpZ2h0ICtcIic+XCIgKyBpbm5lclN2ZyArIFwiPC9zdmc+XCI7XG5cdFx0fSk7XG5cdCAgfVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHR9XG59XG5cbmNsYXNzIFNhbXBsZU1vZGFsIGV4dGVuZHMgTW9kYWwge1xuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCkge1xuXHRcdHN1cGVyKGFwcCk7XG5cdH1cblxuXHRvbk9wZW4oKSB7XG5cdFx0Y29uc3Qge2NvbnRlbnRFbH0gPSB0aGlzO1xuXHRcdGNvbnRlbnRFbC5zZXRUZXh0KCdXb2FoIScpO1xuXHR9XG5cblx0b25DbG9zZSgpIHtcblx0XHRjb25zdCB7Y29udGVudEVsfSA9IHRoaXM7XG5cdFx0Y29udGVudEVsLmVtcHR5KCk7XG5cdH1cbn1cblxuY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IE5TRF9KUztcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBOU0RfSlMpIHtcblx0XHRzdXBlcihhcHAsIHBsdWdpbik7XG5cdFx0dGhpcy5wbHVnaW4gPSBwbHVnaW47XG5cdH1cblxuXHRkaXNwbGF5KCk6IHZvaWQge1xuXHRcdGNvbnN0IHtjb250YWluZXJFbH0gPSB0aGlzO1xuXG5cdFx0Y29udGFpbmVyRWwuZW1wdHkoKTtcblxuXHRcdG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuXHRcdFx0LnNldE5hbWUoJ1NldHRpbmcgIzEnKVxuXHRcdFx0LnNldERlc2MoJ0l0XFwncyBhIHNlY3JldCcpXG5cdFx0XHQuYWRkVGV4dCh0ZXh0ID0+IHRleHRcblx0XHRcdFx0LnNldFBsYWNlaG9sZGVyKCdFbnRlciB5b3VyIHNlY3JldCcpXG5cdFx0XHRcdC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcpXG5cdFx0XHRcdC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXHR9XG59XG4iLCAidHlwZSBCbG9jayA9IHtcbiAgICBzdmdBcHBlbmRpeDogc3RyaW5nO1xuICAgIGNoaWxkcmVuOiBBcnJheTx7IHN0YXJ0X3g6IG51bWJlciwgc3RhcnRfeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9Pjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGFydEVuZEJsb2NrKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgY29udGVudDogc3RyaW5nKTogQmxvY2sge1xuICAgIGNvbnN0IGggPSAyMDtcbiAgICBjb25zdCBzdmdBcHBlbmRpeCA9IGBcbiAgICAgICAgPHJlY3QgeD1cIiR7eH1cIiB5PVwiJHt5fVwiIHdpZHRoPVwiJHt3aWR0aH1cIiBoZWlnaHQ9XCIke2h9XCIgc3Ryb2tlPVwiYmxhY2tcIiBmaWxsPVwibGlnaHRibHVlXCIgLz5cbiAgICAgICAgPHRleHQgeD1cIiR7eCArIHdpZHRoIC8gMn1cIiB5PVwiJHt5ICsgaGVpZ2h0IC8gMn1cIiBmb250LXNpemU9XCIxNHB4XCIgZmlsbD1cImJsYWNrXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIj4ke2NvbnRlbnR9PC90ZXh0PlxuICAgIGA7XG4gICAgcmV0dXJuIHsgc3ZnQXBwZW5kaXgsIGNoaWxkcmVuOiBbXSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VxdWVuY2VCbG9jayh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGNvbnRlbnQ6IHN0cmluZyk6IEJsb2NrIHtcbiAgICBjb25zdCBzdmdBcHBlbmRpeCA9IGBcbiAgICAgICAgPHJlY3QgeD1cIiR7eH1cIiB5PVwiJHt5fVwiIHdpZHRoPVwiJHt3aWR0aH1cIiBoZWlnaHQ9XCIke2hlaWdodH1cIiBzdHJva2U9XCJibGFja1wiIGZpbGw9XCJsaWdodGdyZWVuXCIgLz5cbiAgICAgICAgPHRleHQgeD1cIiR7eCArIHdpZHRoIC8gMn1cIiB5PVwiJHt5ICsgaGVpZ2h0IC8gMn1cIiBmb250LXNpemU9XCIxNHB4XCIgZmlsbD1cImJsYWNrXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIj4ke2NvbnRlbnR9PC90ZXh0PlxuICAgIGA7XG4gICAgcmV0dXJuIHsgc3ZnQXBwZW5kaXgsIGNoaWxkcmVuOiBbXSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVjaXNpb25CbG9jayh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHF1ZXN0aW9uOiBzdHJpbmcsIGFuc3dlckE6IHN0cmluZywgYW5zd2VyQjogc3RyaW5nLCByYXRpbzogbnVtYmVyKTogQmxvY2sge1xuICAgIGNvbnN0IGggPSAyMDtcbiAgICBjb25zdCBoX2V4dHJhID0gaCAvIDI7XG4gICAgbGV0IGxlZnRfb2Zmc2V0ID0gd2lkdGggKiByYXRpbztcbiAgICBsZXQgc3ZnQXBwZW5kaXg6IHN0cmluZztcblxuICAgIGlmIChyYXRpbyA9PT0gLTEpIHtcbiAgICAgICAgbGVmdF9vZmZzZXQgPSB3aWR0aCAqIDAuODtcbiAgICAgICAgc3ZnQXBwZW5kaXggPSBgXG4gICAgICAgICAgICA8cG9seWdvbiBwb2ludHM9XCIke3h9LCR7eX0gJHt4ICsgd2lkdGh9LCR7eX0gJHt4ICsgbGVmdF9vZmZzZXR9LCR7eSArIGh9XCIgc3Ryb2tlPVwiYmxhY2tcIiBmaWxsPVwibGlnaHR5ZWxsb3dcIiAvPlxuICAgICAgICAgICAgPHBvbHlnb24gcG9pbnRzPVwiJHt4fSwke3l9ICR7eH0sJHt5ICsgaCArIGhfZXh0cmF9ICR7eCArIGxlZnRfb2Zmc2V0fSwke3kgKyBoICsgaF9leHRyYX0gJHt4ICsgbGVmdF9vZmZzZXR9LCR7eSArIGh9XCIgc3Ryb2tlPVwiYmxhY2tcIiBmaWxsPVwibGlnaHR5ZWxsb3dcIiAvPlxuICAgICAgICAgICAgPHRleHQgeD1cIiR7eCArIGxlZnRfb2Zmc2V0fVwiIHk9XCIke3kgKyBoIC8gMn1cIiBmb250LXNpemU9XCIxNHB4XCIgZmlsbD1cImJsYWNrXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIj4ke3F1ZXN0aW9ufTwvdGV4dD5cbiAgICAgICAgICAgIDx0ZXh0IHg9XCIke3ggKyB3aWR0aCAvIDh9XCIgeT1cIiR7eSArIGh9XCIgZm9udC1zaXplPVwiMTRweFwiIGZpbGw9XCJibGFja1wiIHRleHQtYW5jaG9yPVwibWlkZGxlXCI+JHthbnN3ZXJBfTwvdGV4dD5cbiAgICAgICAgYDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdmdBcHBlbmRpeCA9IGBcbiAgICAgICAgICAgIDxwb2x5Z29uIHBvaW50cz1cIiR7eH0sJHt5fSAke3ggKyB3aWR0aH0sJHt5fSAke3ggKyBsZWZ0X29mZnNldH0sJHt5ICsgaH1cIiBzdHJva2U9XCJibGFja1wiIGZpbGw9XCJsaWdodHllbGxvd1wiIC8+XG4gICAgICAgICAgICA8cG9seWdvbiBwb2ludHM9XCIke3h9LCR7eX0gJHt4fSwke3kgKyBoICsgaF9leHRyYX0gJHt4ICsgbGVmdF9vZmZzZXR9LCR7eSArIGggKyBoX2V4dHJhfSAke3ggKyBsZWZ0X29mZnNldH0sJHt5ICsgaH1cIiBzdHJva2U9XCJibGFja1wiIGZpbGw9XCJsaWdodHllbGxvd1wiIC8+XG4gICAgICAgICAgICA8cG9seWdvbiBwb2ludHM9XCIke3ggKyB3aWR0aH0sJHt5fSAke3ggKyB3aWR0aH0sJHt5ICsgaCArIGhfZXh0cmF9ICR7eCArIGxlZnRfb2Zmc2V0fSwke3kgKyBoICsgaF9leHRyYX0gJHt4ICsgbGVmdF9vZmZzZXR9LCR7eSArIGh9XCIgc3Ryb2tlPVwiYmxhY2tcIiBmaWxsPVwibGlnaHR5ZWxsb3dcIiAvPlxuICAgICAgICAgICAgPHRleHQgeD1cIiR7eCArIGxlZnRfb2Zmc2V0fVwiIHk9XCIke3kgKyBoIC8gMn1cIiBmb250LXNpemU9XCIxNHB4XCIgZmlsbD1cImJsYWNrXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIj4ke3F1ZXN0aW9ufTwvdGV4dD5cbiAgICAgICAgICAgIDx0ZXh0IHg9XCIke3ggKyA3ICogd2lkdGggLyA4fVwiIHk9XCIke3kgKyBofVwiIGZvbnQtc2l6ZT1cIjE0cHhcIiBmaWxsPVwiYmxhY2tcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPiR7YW5zd2VyQn08L3RleHQ+XG4gICAgICAgICAgICA8dGV4dCB4PVwiJHt4ICsgd2lkdGggLyA4fVwiIHk9XCIke3kgKyBofVwiIGZvbnQtc2l6ZT1cIjE0cHhcIiBmaWxsPVwiYmxhY2tcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPiR7YW5zd2VyQX08L3RleHQ+XG4gICAgICAgIGA7XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRBID0geyBzdGFydF94OiB4LCBzdGFydF95OiB5ICsgaCArIGhfZXh0cmEsIHdpZHRoOiBsZWZ0X29mZnNldCwgaGVpZ2h0OiBoZWlnaHQgLSBoIC0gaF9leHRyYSB9O1xuICAgIGNvbnN0IGNoaWxkQiA9IHsgc3RhcnRfeDogeCArIGxlZnRfb2Zmc2V0LCBzdGFydF95OiB5ICsgaCArIGhfZXh0cmEsIHdpZHRoOiB3aWR0aCAtIGxlZnRfb2Zmc2V0LCBoZWlnaHQ6IGhlaWdodCAtIGggLSBoX2V4dHJhIH07XG5cbiAgICByZXR1cm4geyBzdmdBcHBlbmRpeCwgY2hpbGRyZW46IFtjaGlsZEEsIGNoaWxkQl0gfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByZUxvb3BCbG9jayh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGFyZ3VtZW50c186IHN0cmluZyk6IEJsb2NrIHtcbiAgICBjb25zdCBoID0gMjA7XG4gICAgY29uc3Qgc3ZnQXBwZW5kaXggPSBgXG4gICAgICAgIDxwb2x5Z29uIHBvaW50cz1cIlxuICAgICAgICAgICAgJHt4fSwke3l9XG4gICAgICAgICAgICAke3ggKyB3aWR0aH0sJHt5fVxuICAgICAgICAgICAgJHt4ICsgd2lkdGh9LCR7eSArIGh9XG4gICAgICAgICAgICAke3ggKyBofSwke3kgKyBofVxuICAgICAgICAgICAgJHt4ICsgaH0sJHt5ICsgaGVpZ2h0IC0gaH1cbiAgICAgICAgICAgICR7eCArIHdpZHRofSwke3kgKyBoZWlnaHQgLSBofVxuICAgICAgICAgICAgJHt4ICsgd2lkdGh9LCR7eSArIGhlaWdodH1cbiAgICAgICAgICAgICR7eH0sJHt5ICsgaGVpZ2h0fVxuICAgICAgICAgICAgJHt4fSwke3l9XG4gICAgICAgIFwiIHN0cm9rZT1cImJsYWNrXCIgZmlsbD1cImxpZ2h0cGlua1wiIC8+XG4gICAgICAgIDx0ZXh0IHg9XCIke3ggKyB3aWR0aCAvIDJ9XCIgeT1cIiR7eSArIGggLyAyfVwiIGZvbnQtc2l6ZT1cIjE0cHhcIiBmaWxsPVwiYmxhY2tcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPiR7YXJndW1lbnRzX308L3RleHQ+XG4gICAgYDtcblxuICAgIGNvbnN0IGNoaWxkID0geyBzdGFydF94OiB4ICsgaCwgc3RhcnRfeTogeSArIGgsIHdpZHRoOiB3aWR0aCAtIGgsIGhlaWdodDogaGVpZ2h0IC0gMiAqIGggfTtcblxuICAgIHJldHVybiB7IHN2Z0FwcGVuZGl4LCBjaGlsZHJlbjogW2NoaWxkXSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9zdExvb3BCbG9jayh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIGFyZ3VtZW50c186IHN0cmluZyk6IEJsb2NrIHtcbiAgICBjb25zdCBoID0gMjA7XG4gICAgY29uc3Qgc3ZnQXBwZW5kaXggPSBgXG4gICAgICAgIDxwb2x5Z29uIHBvaW50cz1cIlxuICAgICAgICAgICAgJHt4fSwke3l9XG4gICAgICAgICAgICAke3ggKyB3aWR0aH0sJHt5fVxuICAgICAgICAgICAgJHt4ICsgd2lkdGh9LCR7eSArIGh9XG4gICAgICAgICAgICAke3ggKyBofSwke3kgKyBofVxuICAgICAgICAgICAgJHt4ICsgaH0sJHt5ICsgaGVpZ2h0IC0gaH1cbiAgICAgICAgICAgICR7eCArIHdpZHRofSwke3kgKyBoZWlnaHQgLSBofVxuICAgICAgICAgICAgJHt4ICsgd2lkdGh9LCR7eSArIGhlaWdodH1cbiAgICAgICAgICAgICR7eH0sJHt5ICsgaGVpZ2h0fVxuICAgICAgICAgICAgJHt4fSwke3l9XG4gICAgICAgIFwiIHN0cm9rZT1cImJsYWNrXCIgZmlsbD1cImxpZ2h0cGlua1wiIC8+XG4gICAgICAgIDx0ZXh0IHg9XCIke3ggKyB3aWR0aCAvIDJ9XCIgeT1cIiR7eSArIGggLyAyfVwiIGZvbnQtc2l6ZT1cIjE0cHhcIiBmaWxsPVwiYmxhY2tcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiPmRvPC90ZXh0PlxuICAgICAgICA8dGV4dCB4PVwiJHt4ICsgd2lkdGggLyAyfVwiIHk9XCIke3kgKyBoZWlnaHQgLSBoIC8gMn1cIiBmb250LXNpemU9XCIxNHB4XCIgZmlsbD1cImJsYWNrXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIj53aGlsZSgke2FyZ3VtZW50c199KTwvdGV4dD5cbiAgICBgO1xuXG4gICAgY29uc3QgY2hpbGQgPSB7IHN0YXJ0X3g6IHggKyBoLCBzdGFydF95OiB5ICsgaCwgd2lkdGg6IHdpZHRoIC0gaCwgaGVpZ2h0OiBoZWlnaHQgLSAyICogaCB9O1xuXG4gICAgcmV0dXJuIHsgc3ZnQXBwZW5kaXgsIGNoaWxkcmVuOiBbY2hpbGRdIH07XG59XG5cbi8vIFRPRE86IGZ1bmN0aW9uIGNyZWF0ZVN3aXRjaENhc2VCbG9ja1xuLy8gbW9yZS4uLlxuIiwgImltcG9ydCB7IGNyZWF0ZURlY2lzaW9uQmxvY2ssIGNyZWF0ZVNlcXVlbmNlQmxvY2ssIGNyZWF0ZVN0YXJ0RW5kQmxvY2ssIGNyZWF0ZVBvc3RMb29wQmxvY2ssIGNyZWF0ZVByZUxvb3BCbG9jayB9IGZyb20gXCIuL25hc3NpX3N2Z19hcGlcIlxuaW1wb3J0IHsgdG9rZW4gfSBmcm9tIFwiLi90eXBlcy90b2tlblwiXG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0KHggOiBudW1iZXIsIHkgOiBudW1iZXIsIHdpZHRoIDogbnVtYmVyLCBoZWlnaHQgOiBudW1iZXIsIHRyZWUgOiB0b2tlbltdLCBuYW1lIDogc3RyaW5nKSB7XG4gICAgbGV0IHN2ZyA9ICcnXG4gICAgc3ZnICs9IGNyZWF0ZVN0YXJ0RW5kQmxvY2soeCwgeSwgd2lkdGgsIDIwLCBuYW1lKS5zdmdBcHBlbmRpeFxuICAgIGxldCBjb252ZXJzaW9uID0gY29udmVydF9iYWNrZW5kKHgsIHkgKyAyMCwgd2lkdGgsIGhlaWdodCAtIDIwLCB0cmVlKVxuICAgIHN2ZyArPSBjb252ZXJzaW9uLnN2Z0FwcGVuZGl4XG4gICAgc3ZnICs9IGNyZWF0ZVN0YXJ0RW5kQmxvY2soeCwgeSArIDIwICsgY29udmVyc2lvbi5oZWlnaHQsIHdpZHRoLCAyMCwgXCJFbmRcIikuc3ZnQXBwZW5kaXhcbiAgICByZXR1cm4ge3N2Z1N0cmluZzogc3ZnLCBoZWlnaHQ6IGNvbnZlcnNpb24uaGVpZ2h0ICsgNDB9XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRfYmFja2VuZCh4ICA6IG51bWJlciwgeSA6IG51bWJlciwgd2lkdGggOiBudW1iZXIsIGhlaWdodCA6IG51bWJlciwgdHJlZTogdG9rZW5bXSkge1xuICAgIGNvbnNvbGUubG9nKFwiQ29udmVydGluZyBcIiwgdHJlZSlcbiAgICBsZXQgc3ZnQXBwZW5kaXggPSAnJ1xuICAgIC8vbGV0IGggPSBoZWlnaHQgLyB0cmVlLmxlbmd0aFxuICAgIGxldCBjdXJyZW50X3kgPSB5XG4gICAgXG4gICAgZm9yIChsZXQgYmxvY2sgb2YgdHJlZSkge1xuICAgICAgICBsZXQgaCA9IGdldEhlaWdodChibG9jaylcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gLTEpIHsgXG4gICAgICAgICAgICBzdmdBcHBlbmRpeCArPSBjcmVhdGVTZXF1ZW5jZUJsb2NrKHgsIGN1cnJlbnRfeSwgd2lkdGgsIGgsIGJsb2NrLm5hbWUpLnN2Z0FwcGVuZGl4XG4gICAgICAgICAgICBjdXJyZW50X3kgKz0gaFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJsb2NrLnR5cGUgPT0gMCkge1xuICAgICAgICAgICAgc3ZnQXBwZW5kaXggKz0gY3JlYXRlU2VxdWVuY2VCbG9jayh4LCBjdXJyZW50X3ksIHdpZHRoLCBoLCBibG9jay5uYW1lICsgJygnICsgYmxvY2suYXJndW1lbnRzWzBdICsgJyknKS5zdmdBcHBlbmRpeFxuICAgICAgICAgICAgY3VycmVudF95ICs9IGhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9jay50eXBlID09IDEpIHsgLy9pZnNcbiAgICAgICAgICAgIGlmIChibG9jay5icmFuY2hlcy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMSBicmFuY2hlcywgTmFzc2ktU2huZWlkZXJtYW4gZGlhZ3JhbXMgb25seSBzdXBwb3J0IHNpbmdsZSBJRiBvciBvbmUgSUYtRUxTRSBzdGF0ZW1lbnQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN1Yl9ibG9jayA9IGNyZWF0ZURlY2lzaW9uQmxvY2soeCwgY3VycmVudF95LCB3aWR0aCwgaCwgYmxvY2submFtZSArICcoJyArIGJsb2NrLmFyZ3VtZW50c1swXSArICcpJywgXCJUUlVFXCIsIFwiRkFMU0VcIiwgLTEpO1xuICAgICAgICAgICAgc3ZnQXBwZW5kaXggKz0gc3ViX2Jsb2NrLnN2Z0FwcGVuZGl4O1xuICAgICAgICAgICAgdmFyIGJvdW5kczEgPSBzdWJfYmxvY2suY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBzdmdBcHBlbmRpeCArPSBjb252ZXJ0X2JhY2tlbmQoYm91bmRzMS5zdGFydF94LCBib3VuZHMxLnN0YXJ0X3ksIGJvdW5kczEud2lkdGgsIGJvdW5kczEuaGVpZ2h0LCBibG9jay5icmFuY2hlc1swXSkuc3ZnQXBwZW5kaXg7XG4gICAgICAgICAgICBjdXJyZW50X3kgKz0gaFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJsb2NrLnR5cGUgPT0gMikgeyAvL2lmcyBhbmQgZWxzZVxuICAgICAgICAgICAgaWYgKGJsb2NrLmJyYW5jaGVzLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCAyIGJyYW5jaGVzLCBOYXNzaS1TaG5laWRlcm1hbiBkaWFncmFtcyBvbmx5IHN1cHBvcnQgc2luZ2xlIElGIG9yIG9uZSBJRi1FTFNFIHN0YXRlbWVudCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmF0aW8gPSBnZXRNYXhDaGlsZENvdW50KGJsb2NrLmJyYW5jaGVzWzBdKSAvIChnZXRNYXhDaGlsZENvdW50KGJsb2NrLmJyYW5jaGVzWzBdKSArIGdldE1heENoaWxkQ291bnQoYmxvY2suYnJhbmNoZXNbMV0pKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJSQVRJT1wiLCByYXRpbyk7XG4gICAgICAgICAgICB2YXIgc3ViX2Jsb2NrID0gY3JlYXRlRGVjaXNpb25CbG9jayh4LCBjdXJyZW50X3ksIHdpZHRoLCBoLCBibG9jay5uYW1lICsgJygnICsgYmxvY2suYXJndW1lbnRzWzBdICsgJyknLCBcIlRSVUVcIiwgXCJGQUxTRVwiLCByYXRpbyk7XG4gICAgICAgICAgICBzdmdBcHBlbmRpeCArPSBzdWJfYmxvY2suc3ZnQXBwZW5kaXg7XG4gICAgICAgICAgICB2YXIgYm91bmRzMSA9IHN1Yl9ibG9jay5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHZhciBib3VuZHMyID0gc3ViX2Jsb2NrLmNoaWxkcmVuWzFdO1xuICAgICAgICAgICAgc3ZnQXBwZW5kaXggKz0gY29udmVydF9iYWNrZW5kKGJvdW5kczEuc3RhcnRfeCwgYm91bmRzMS5zdGFydF95LCBib3VuZHMxLndpZHRoLCBib3VuZHMxLmhlaWdodCwgYmxvY2suYnJhbmNoZXNbMF0pLnN2Z0FwcGVuZGl4O1xuICAgICAgICAgICAgc3ZnQXBwZW5kaXggKz0gY29udmVydF9iYWNrZW5kKGJvdW5kczIuc3RhcnRfeCwgYm91bmRzMi5zdGFydF95LCBib3VuZHMyLndpZHRoLCBib3VuZHMyLmhlaWdodCwgYmxvY2suYnJhbmNoZXNbMV0pLnN2Z0FwcGVuZGl4O1xuICAgICAgICAgICAgY3VycmVudF95ICs9IGhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9jay50eXBlID09IDEwKSB7IC8vbG9vcHNcbiAgICAgICAgICAgIGlmIChibG9jay5icmFuY2hlcy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMSBicmFuY2hlcywgTmFzc2ktU2huZWlkZXJtYW4gZGlhZ3JhbXMgb25seSBzdXBwb3J0IHNpbmdsZSBsb29wJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdWJfYmxvY2sgPSBjcmVhdGVQcmVMb29wQmxvY2soeCwgY3VycmVudF95LCB3aWR0aCwgaCwgYmxvY2submFtZSArICcoJyArIGJsb2NrLmFyZ3VtZW50c1swXSArICcpJyk7XG4gICAgICAgICAgICBzdmdBcHBlbmRpeCArPSBzdWJfYmxvY2suc3ZnQXBwZW5kaXg7XG4gICAgICAgICAgICB2YXIgYm91bmRzMSA9IHN1Yl9ibG9jay5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHN2Z0FwcGVuZGl4ICs9IGNvbnZlcnRfYmFja2VuZChib3VuZHMxLnN0YXJ0X3gsIGJvdW5kczEuc3RhcnRfeSwgYm91bmRzMS53aWR0aCwgYm91bmRzMS5oZWlnaHQsIGJsb2NrLmJyYW5jaGVzWzBdKS5zdmdBcHBlbmRpeDtcbiAgICAgICAgICAgIGN1cnJlbnRfeSArPSBoXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2sudHlwZSA9PSAxMSkgeyAvL3Bvc3QtbG9vcHNcbiAgICAgICAgICAgIGlmIChibG9jay5icmFuY2hlcy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMSBicmFuY2hlcywgTmFzc2ktU2huZWlkZXJtYW4gZGlhZ3JhbXMgb25seSBzdXBwb3J0IHNpbmdsZSBsb29wJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdWJfYmxvY2sgPSBjcmVhdGVQb3N0TG9vcEJsb2NrKHgsIGN1cnJlbnRfeSwgd2lkdGgsIGgsIGJsb2NrLm5hbWUgKyAnKCcgKyBibG9jay5hcmd1bWVudHNbMF0gKyAnKScpO1xuICAgICAgICAgICAgc3ZnQXBwZW5kaXggKz0gc3ViX2Jsb2NrLnN2Z0FwcGVuZGl4O1xuICAgICAgICAgICAgdmFyIGJvdW5kczEgPSBzdWJfYmxvY2suY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBzdmdBcHBlbmRpeCArPSBjb252ZXJ0X2JhY2tlbmQoYm91bmRzMS5zdGFydF94LCBib3VuZHMxLnN0YXJ0X3ksIGJvdW5kczEud2lkdGgsIGJvdW5kczEuaGVpZ2h0LCBibG9jay5icmFuY2hlc1swXSkuc3ZnQXBwZW5kaXg7XG4gICAgICAgICAgICBjdXJyZW50X3kgKz0gaFxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7c3ZnQXBwZW5kaXg6IHN2Z0FwcGVuZGl4LCBoZWlnaHQ6IGN1cnJlbnRfeSAtIHl9XG59XG5cbmZ1bmN0aW9uIGdldE1heENoaWxkQ291bnQoYnJhbmNoIDogdG9rZW5bXSkgOiBudW1iZXIge1xuICAgIGxldCBjb3VudHMgPSBbXVxuICAgIGZvciAobGV0IGJsb2NrIG9mIGJyYW5jaCkge1xuICAgICAgICBpZiAoYmxvY2sudHlwZSA9PSAwIHx8IGJsb2NrLnR5cGUgPT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50cy5wdXNoKDEpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2sudHlwZSA9PSAyKSB7XG4gICAgICAgICAgICBsZXQgY291bnRBID0gZ2V0TWF4Q2hpbGRDb3VudChibG9jay5icmFuY2hlc1swXSlcblxuICAgICAgICAgICAgbGV0IGNvdW50QiA9IGdldE1heENoaWxkQ291bnQoYmxvY2suYnJhbmNoZXNbMV0pXG5cbiAgICAgICAgICAgIGNvdW50cy5wdXNoKGNvdW50QSArIGNvdW50QilcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvdW50cy5wdXNoKGdldE1heENoaWxkQ291bnQoYmxvY2suYnJhbmNoZXNbMF0pKVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1heCguLi5jb3VudHMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWlnaHQoYmxvY2sgOiB0b2tlbikge1xuICAgIGNvbnN0IGJhc2VfaCA9IDIwO1xuICAgIGlmIChibG9jay50eXBlID09IDAgfHwgYmxvY2sudHlwZSA9PSAtMSkge1xuICAgICAgICByZXR1cm4gYmFzZV9oXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgaGVpZ2h0cyA6IG51bWJlcltdID0gW11cbiAgICAgICAgY29uc29sZS5sb2coYmxvY2spXG4gICAgICAgIGZvciAobGV0IGJyYW5jaCBvZiBibG9jay5icmFuY2hlcykge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRfaGVpZ3RoID0gMFxuICAgICAgICAgICAgZm9yIChsZXQgc3ViX2Jsb2NrIG9mIGJyYW5jaCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRfaGVpZ3RoICs9IGdldEhlaWdodChzdWJfYmxvY2spXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWlnaHRzLnB1c2goY3VycmVudF9oZWlndGgpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgPT0gMTAgfHwgYmxvY2sudHlwZSA9PSAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VfaCAqIDIgKyBNYXRoLm1heCguLi5oZWlnaHRzKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJsb2NrLnR5cGUgPT0gMSB8fCBibG9jay50eXBlID09IDIpIHsgIFxuICAgICAgICAgICAgcmV0dXJuIGJhc2VfaCAqIDMgLyAyICsgTWF0aC5tYXgoLi4uaGVpZ2h0cylcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMFxufSIsICJpbXBvcnQgeyB0b2tlbiB9IGZyb20gJy4vdHlwZXMvdG9rZW4nXG5cbmNvbnN0IHRva2VucyA9IFsnaWYnLCAnZm9yJywgJ2ZvcmVhY2gnLCAnd2hpbGUnLCAnZG8nXVxuY29uc3QgYnJhbmNoZXJzID0gWyd7JywgJ30nXVxuY29uc3QgYnJhY2tldHMgPSBbJygnLCAnKSddXG5cbi8vIC0xIGFzc2lnbm1lbnRcbi8vIDA6IGZ1bmN0aW9uIGNhbGxcbi8vIDE6IGlmc1xuLy8gMjogaWZzIGFuZCBlbHNlXG4vLyAxMDogcHJlLWxvb3Bcbi8vIDExOiBwb3N0LWxvb3BcblxuZnVuY3Rpb24gaXNfdG9rZW4ocyA6IHN0cmluZykge1xuICAgIHJldHVybiB0b2tlbnMuaW5jbHVkZXMocylcbn1cblxuZnVuY3Rpb24gaXNfdG9rZW5fcHJlZml4KHMgOiBzdHJpbmcpIHsgLy9tYXliZSBub3QgdGhlIGNvcnJlY3QgZGVmIG9mIHByZWZpeFxuICAgIGlmIChpc190b2tlbihzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRva2Vuc1tpXS5zdGFydHNXaXRoKHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBnZXRfYXJndW1lbnRzKHMgOiBzdHJpbmcsIGkgOiBudW1iZXIpIDoge2FyZ3M6IHN0cmluZywgaW5kZXg6IG51bWJlcn0ge1xuICAgIGlmIChzW2ldICE9PSBicmFja2V0c1swXSkge1xuICAgICAgICBjb25zb2xlLmxvZyhzW2ldKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkICgnKVxuICAgIH1cbiAgICBsZXQgYXJndW1lbnRzXyA9ICcnXG4gICAgbGV0IG5leHRfY2hhciA9IHNbaSArIDFdXG4gICAgaSArPSAxXG4gICAgd2hpbGUgKG5leHRfY2hhciAhPT0gYnJhY2tldHNbMV0pIHtcbiAgICAgICAgYXJndW1lbnRzXyArPSBzW2ldXG4gICAgICAgIGkrK1xuICAgICAgICBuZXh0X2NoYXIgPSBzW2ldXG4gICAgfVxuICAgIHJldHVybiB7YXJnczogYXJndW1lbnRzXywgaW5kZXg6IGkgKyAxfVxufVxuXG5mdW5jdGlvbiBnZXRfYnJhbmNoKHMgOiBzdHJpbmcsIGkgOiBudW1iZXIpIHtcbiAgICB2YXIgYnJhbmNoID0gJydcbiAgICB2YXIgb3Blbl9icmFja2V0cyA9IDBcbiAgICB3aGlsZSAob3Blbl9icmFja2V0cyA+PSAwKSB7XG4gICAgICAgIGlmIChpID4gcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgfScpXG4gICAgICAgIH1cbiAgICAgICAgYnJhbmNoICs9IHNbaV1cbiAgICAgICAgaSsrXG4gICAgICAgIGlmIChzW2ldID09PSBicmFuY2hlcnNbMF0pIHtcbiAgICAgICAgICAgIG9wZW5fYnJhY2tldHMrK1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNbaV0gPT09IGJyYW5jaGVyc1sxXSkge1xuICAgICAgICAgICAgb3Blbl9icmFja2V0cy0tXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtjb250ZW50OiBicmFuY2gsIGluZGV4OiBpICsgMX1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxleF9mcm9udChzIDogc3RyaW5nKSB7XG4gICAgbGV0IHdpdGhvdXRfc3BhY2VzID0gcy5yZXBsYWNlKC9cXHMvZywgJycpICBcbiAgICAvL2xldCB3aXRob3V0X3NwYWNlc19hbmRfc2VtaWNvbG9ucyA9IHdpdGhvdXRfc3BhY2VzLnJlcGxhY2UoLzsvZywgJycpXG4gICAgcmV0dXJuIGxleF9iYWNrKHdpdGhvdXRfc3BhY2VzKVxufVxuXG5mdW5jdGlvbiBsZXhfYmFjayhzIDogc3RyaW5nKSA6IHRva2VuW10ge1xuICAgIGNvbnNvbGUubG9nKFwiQ29tcGlsaW5nOiBcIiArIHMpXG4gICAgbGV0IGkgPSAwXG4gICAgbGV0IGN1cnJlbnRfdG9rZW4gPSAnJ1xuICAgIGxldCB0b2tlbnMgPSBbXVxuICAgIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKGlzX3Rva2VuX3ByZWZpeChjdXJyZW50X3Rva2VuKSkge1xuICAgICAgICAgICAgY3VycmVudF90b2tlbiArPSBzW2ldXG4gICAgICAgICAgICBpKytcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfdG9rZW4oY3VycmVudF90b2tlbikpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50X3Rva2VuID09PSAnaWYnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSAxXG4gICAgICAgICAgICAgICAgbGV0IGJyYW5jaGVzIDogdG9rZW5bXVtdID0gW11cbiAgICAgICAgICAgICAgICBsZXQgYXJndW1lbnRzXyA6IHN0cmluZ1tdID0gW11cblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X2FyZ3VtZW50cyA9IGdldF9hcmd1bWVudHMocywgaSlcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudF9hcmd1bWVudHMuaW5kZXhcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjdXJyZW50X2FyZ3VtZW50cy5hcmdzKVxuXG4gICAgICAgICAgICAgICAgaWYgKHNbaV0gIT09IGJyYW5jaGVyc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHsnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpICs9IDFcbiAgICAgICAgICAgICAgICB2YXIgYnJhbmNoID0gZ2V0X2JyYW5jaChzLCBpKVxuICAgICAgICAgICAgICAgIGkgPSBicmFuY2guaW5kZXhcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBicmFuY2hlcy5wdXNoKGxleF9iYWNrKGJyYW5jaC5jb250ZW50KSlcbiAgICAgICAgICAgICAgICBhcmd1bWVudHNfLnB1c2goY3VycmVudF9hcmd1bWVudHMuYXJncylcblxuICAgICAgICAgICAgICAgIHdoaWxlIChzLnN1YnN0cmluZyhpLCBpICsgNikgPT09ICdlbHNlaWYnKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gNlxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudF9hcmd1bWVudHMgPSBnZXRfYXJndW1lbnRzKHMsIGkpXG4gICAgICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50X2FyZ3VtZW50cy5pbmRleFxuICAgICAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPT0gYnJhbmNoZXJzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHsnKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMVxuICAgICAgICAgICAgICAgICAgICB2YXIgYnJhbmNoID0gZ2V0X2JyYW5jaChzLCBpKVxuICAgICAgICAgICAgICAgICAgICBpID0gYnJhbmNoLmluZGV4XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBicmFuY2hlcy5wdXNoKGxleF9iYWNrKGJyYW5jaC5jb250ZW50KSlcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzXy5wdXNoKGN1cnJlbnRfYXJndW1lbnRzLmFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzLnN1YnN0cmluZyhpLCBpICsgNCkgPT09ICdlbHNlJykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gMlxuICAgICAgICAgICAgICAgICAgICBpICs9IDRcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxXG4gICAgICAgICAgICAgICAgICAgIHZhciBicmFuY2ggPSBnZXRfYnJhbmNoKHMsIGkpXG4gICAgICAgICAgICAgICAgICAgIGkgPSBicmFuY2guaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaGVzLnB1c2gobGV4X2JhY2soYnJhbmNoLmNvbnRlbnQpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY3VycmVudF90b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNfLFxuICAgICAgICAgICAgICAgICAgICBicmFuY2hlczogYnJhbmNoZXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudF90b2tlbiA9PT0gJ2ZvcicgfHwgY3VycmVudF90b2tlbiA9PT0gJ2ZvcmVhY2gnIHx8IGN1cnJlbnRfdG9rZW4gPT09ICd3aGlsZScpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IDEwXG4gICAgICAgICAgICAgICAgdmFyIGJyYW5jaGVzIDogdG9rZW5bXVtdID0gW11cbiAgICAgICAgICAgICAgICB2YXIgYXJndW1lbnRzXyA6IHN0cmluZ1tdID0gW11cblxuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X2FyZ3VtZW50cyA9IGdldF9hcmd1bWVudHMocywgaSlcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudF9hcmd1bWVudHMuaW5kZXhcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGN1cnJlbnRfYXJndW1lbnRzLmFyZ3MpXG5cbiAgICAgICAgICAgICAgICBpZiAoc1tpXSAhPT0gYnJhbmNoZXJzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNbaV0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgeycpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgKz0gMVxuICAgICAgICAgICAgICAgIHZhciBicmFuY2ggPSBnZXRfYnJhbmNoKHMsIGkpXG4gICAgICAgICAgICAgICAgaSA9IGJyYW5jaC5pbmRleFxuXG4gICAgICAgICAgICAgICAgYnJhbmNoZXMucHVzaChsZXhfYmFjayhicmFuY2guY29udGVudCkpXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzXy5wdXNoKGN1cnJlbnRfYXJndW1lbnRzLmFyZ3MpXG5cbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGN1cnJlbnRfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzXyxcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoZXM6IGJyYW5jaGVzXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJlbnRfdG9rZW4gPT0gJ2RvJykge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gMTFcbiAgICAgICAgICAgICAgICB2YXIgYnJhbmNoZXMgOiB0b2tlbltdW10gPSBbXVxuICAgICAgICAgICAgICAgIHZhciBhcmd1bWVudHNfIDogc3RyaW5nW10gPSBbXVxuXG4gICAgICAgICAgICAgICAgaWYgKHNbaV0gIT09IGJyYW5jaGVyc1swXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzW2ldKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHsnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpICs9IDFcbiAgICAgICAgICAgICAgICB2YXIgYnJhbmNoID0gZ2V0X2JyYW5jaChzLCBpKVxuICAgICAgICAgICAgICAgIGkgPSBicmFuY2guaW5kZXhcblxuICAgICAgICAgICAgICAgIGJyYW5jaGVzLnB1c2gobGV4X2JhY2soYnJhbmNoLmNvbnRlbnQpKVxuXG4gICAgICAgICAgICAgICAgaWYgKHMuc3Vic3RyaW5nKGksIGkgKyA1KSAhPT0gJ3doaWxlJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHdoaWxlJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSArPSA1XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRfYXJndW1lbnRzID0gZ2V0X2FyZ3VtZW50cyhzLCBpKVxuICAgICAgICAgICAgICAgIGFyZ3VtZW50c18ucHVzaChjdXJyZW50X2FyZ3VtZW50cy5hcmdzKVxuICAgICAgICAgICAgICAgIGkgPSBjdXJyZW50X2FyZ3VtZW50cy5pbmRleFxuXG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjdXJyZW50X3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c18sXG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaGVzOiBicmFuY2hlc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoc1tpXSAhPSBicmFja2V0c1swXSAmJiBzW2ldICE9ICc7Jykge1xuICAgICAgICAgICAgICAgIGlmIChpID49IHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgKCBvciA7JylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudF90b2tlbiArPSBzW2ldXG4gICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc1tpXSA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogY3VycmVudF90b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoZXM6IFtdXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X2FyZ3VtZW50cyA9IGdldF9hcmd1bWVudHMocywgaSlcbiAgICAgICAgICAgICAgICBpID0gY3VycmVudF9hcmd1bWVudHMuaW5kZXhcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IDAsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGN1cnJlbnRfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW2N1cnJlbnRfYXJndW1lbnRzLmFyZ3NdLFxuICAgICAgICAgICAgICAgICAgICBicmFuY2hlczogW11cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGlmIChzW2ldID09ICc7Jykge1xuICAgICAgICAgICAgICAgICAgICBpICs9IDFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudF90b2tlbiA9ICcnXG4gICAgfVxuICAgIHJldHVybiB0b2tlbnNcbn0iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQTRGOzs7QUNLckYsU0FBUyxvQkFBb0IsR0FBVyxHQUFXLE9BQWUsUUFBZ0IsU0FBd0I7QUFDN0csUUFBTSxJQUFJO0FBQ1YsUUFBTSxjQUFjO0FBQUEsbUJBQ0wsU0FBUyxhQUFhLGtCQUFrQjtBQUFBLG1CQUN4QyxJQUFJLFFBQVEsU0FBUyxJQUFJLFNBQVMseURBQXlEO0FBQUE7QUFFMUcsU0FBTyxFQUFFLGFBQWEsVUFBVSxDQUFDLEVBQUU7QUFDdkM7QUFFTyxTQUFTLG9CQUFvQixHQUFXLEdBQVcsT0FBZSxRQUFnQixTQUF3QjtBQUM3RyxRQUFNLGNBQWM7QUFBQSxtQkFDTCxTQUFTLGFBQWEsa0JBQWtCO0FBQUEsbUJBQ3hDLElBQUksUUFBUSxTQUFTLElBQUksU0FBUyx5REFBeUQ7QUFBQTtBQUUxRyxTQUFPLEVBQUUsYUFBYSxVQUFVLENBQUMsRUFBRTtBQUN2QztBQUVPLFNBQVMsb0JBQW9CLEdBQVcsR0FBVyxPQUFlLFFBQWdCLFVBQWtCLFNBQWlCLFNBQWlCLE9BQXNCO0FBQy9KLFFBQU0sSUFBSTtBQUNWLFFBQU0sVUFBVSxJQUFJO0FBQ3BCLE1BQUksY0FBYyxRQUFRO0FBQzFCLE1BQUk7QUFFSixNQUFJLFVBQVUsSUFBSTtBQUNkLGtCQUFjLFFBQVE7QUFDdEIsa0JBQWM7QUFBQSwrQkFDUyxLQUFLLEtBQUssSUFBSSxTQUFTLEtBQUssSUFBSSxlQUFlLElBQUk7QUFBQSwrQkFDbkQsS0FBSyxLQUFLLEtBQUssSUFBSSxJQUFJLFdBQVcsSUFBSSxlQUFlLElBQUksSUFBSSxXQUFXLElBQUksZUFBZSxJQUFJO0FBQUEsdUJBQ3ZHLElBQUksbUJBQW1CLElBQUks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LENBQUM7QUFDMUMsbUJBQVcsS0FBSyxrQkFBa0IsSUFBSTtBQUN0QyxZQUFJLGtCQUFrQjtBQUV0QixRQUFBQSxRQUFPLEtBQUs7QUFBQSxVQUNSO0FBQUEsVUFDQSxNQUFNO0FBQUEsVUFDTixXQUFXO0FBQUEsVUFDWDtBQUFBLFFBQ0osQ0FBQztBQUFBLE1BQ0w7QUFBQSxJQUNKLE9BQ0s7QUFDRCxhQUFPLEVBQUUsQ0FBQyxLQUFLLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxLQUFLLEtBQUs7QUFDdkMsWUFBSSxLQUFLLEVBQUUsUUFBUTtBQUNmLGdCQUFNLElBQUksTUFBTSxpQkFBaUI7QUFBQSxRQUNyQztBQUNBLHlCQUFpQixFQUFFLENBQUM7QUFDcEI7QUFBQSxNQUNKO0FBQ0EsVUFBSSxFQUFFLENBQUMsTUFBTSxLQUFLO0FBQ2Q7QUFDQSxRQUFBQSxRQUFPLEtBQUs7QUFBQSxVQUNSLE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxVQUNOLFdBQVcsQ0FBQztBQUFBLFVBQ1osVUFBVSxDQUFDO0FBQUEsUUFDZixDQUFDO0FBQUEsTUFDTCxPQUNLO0FBQ0QsWUFBSSxvQkFBb0IsY0FBYyxHQUFHLENBQUM7QUFDMUMsWUFBSSxrQkFBa0I7QUFDdEIsUUFBQUEsUUFBTyxLQUFLO0FBQUEsVUFDUixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixXQUFXLENBQUMsa0JBQWtCLElBQUk7QUFBQSxVQUNsQyxVQUFVLENBQUM7QUFBQSxRQUNmLENBQUM7QUFDRCxZQUFJLEVBQUUsQ0FBQyxLQUFLLEtBQUs7QUFDYixlQUFLO0FBQUEsUUFDVDtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQ0Esb0JBQWdCO0FBQUEsRUFDcEI7QUFDQSxTQUFPQTtBQUNYOzs7QUh4TkEsSUFBTSxtQkFBcUM7QUFBQSxFQUMxQyxXQUFXO0FBQ1o7QUFFQSxJQUFxQixTQUFyQixjQUFvQyx1QkFBTztBQUFBLEVBRzFDLE1BQU0sU0FBUztBQUNkLFNBQUssbUNBQW1DLFVBQVUsQ0FBQyxRQUFRLElBQUksUUFBUTtBQUN0RSxZQUFNLE9BQU8sVUFBVSxNQUFNO0FBQzdCLFlBQU0sTUFBTSxRQUFRLEdBQUcsR0FBRyxLQUFLLEtBQU0sTUFBTSxPQUFPO0FBQ2xELFlBQU0sV0FBVyxJQUFJO0FBQ3JCLFlBQU0sU0FBUyxJQUFJO0FBQ25CLFNBQUcsWUFBWSw4QkFBOEIsU0FBUSxPQUFPLFdBQVc7QUFBQSxJQUN4RSxDQUFDO0FBQUEsRUFDQTtBQUFBLEVBRUYsTUFBTSxlQUFlO0FBQ3BCLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBQUEsRUFDMUU7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNwQixVQUFNLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFBQSxFQUNsQztBQUNEOyIsCiAgIm5hbWVzIjogWyJ0b2tlbnMiLCAiYnJhbmNoZXMiLCAiYXJndW1lbnRzXyJdCn0K
